use strict;
use warnings;
use Digest::SHA qw(sha256_hex);

my $file1 = "msg.in";
my $file2 = "msg.dec";
my $file3 = "msg.enc";

my $filesize = 500 + int(rand(1000)); # $filesize will be set pseudorandomly to
                                      # between 500 and 1499 (inclusive).

# Generate a "msg.in" that contains $filesize pseudorandomly generated bytes.

open my $wr, '>', "msg.in" or die "Cannot open 'msg.in' for writing";
binmode($wr);

for(1..$filesize) {
  unless($_ % 91) { print $wr chr(0) } # embed some NULL bytes
  print $wr chr(int(rand(256)));
}

my $nulls = int(rand(6));

for(0..$nulls) { print $wr chr(0) }         # add from 0 to 5 of NULL bytes

close $wr or die "Cannot close 'msg.in' after writing";

my($enc, $dec);

# Determine whether the files have the ".exe" extension or no extension.

if(-e "encrypt.exe")        { $enc = "encrypt.exe" }
elsif(-e "encrypt") { $enc = "encrypt" }
else { die "Cannot find the encrypt executable" }


if(-e "decrypt.exe")        { $dec = "decrypt.exe" }
elsif(-e "decrypt") { $dec = "decrypt" }
else { die "Cannot find the decrypt executable" }

if($^O =~ /MSWin32/i) {
  $enc = ".\\" . $enc;
  $dec = ".\\" . $dec;
}
else {
  $enc = "./" . $enc;
  $dec = "./" . $dec;
}

# Run encryption and decryption of "msg.in" 100 times - each time a different seed will be used,
# resulting in a different "msg.enc".
# For each iteration we check:
#   1) that the original "msg.in" is identical to the derived "msg.dec";
#   2) that the current "msg.enc" differs from the "msg.enc" produced by the previous iteration.

my $digest4 = '';  # will be overwritten to $digest3 at each iteration

for(1..100) {
  system $enc;
  system $dec;
  my $digest1 = dig($file1);
  my $digest2 = dig($file2);
  my $digest3 = dig($file3);

  if($digest1 eq $digest2 && $digest3 ne $digest2 && $digest3 ne $digest4) {
    print "ok $_\n";
  }
  else {
    die "Failed for $_:\n$digest1\n$digest2\n$digest3\n $digest4\n";
  }

  $digest4 = $digest3;
}

sub dig {
  # Return the SHA-256 hex digest of the specified file
  open(my $RD1, $_[0]) or warn "Can't open $_[0]: $!";
  binmode($RD1);
  my $sha256 = Digest::SHA->new(256);
  $sha256->addfile($RD1);
  my $digest = $sha256->hexdigest;
  close($RD1) or warn "Can't close $_[0]: $!";
  return $digest;
}
