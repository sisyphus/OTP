
A silly little one time pad exercise, using the MicaliSchnorr CSPRBG as given by Algorithm 5.37 in
"Handbook of Applied Cryptography" by Menezes et al.

The gmp library (https://gmplib.org) is required.

Run:
gcc -o encrypt.exe encrypt.c -lgmp
gcc -o decrypt.exe decrypt.c -lgmp

Create a file named "msg.in", in the same directory as the 2 executables.

Run:
encrypt.exe
and the contents of "msg.in" is encrypted (based on the contents of "next_seed.txt" and "primes.in".
The encrypted version of "msg.in" is then written to msg.enc.

Run:
decrypt.exe
and the encrypted "msg.enc" is decrypted into "msg.dec", where "msg.dec" is identical to "msg.in".

Decryption requires only that the same "primes.in" as was used to encrypt the message is available.

Security relies on "primes.in" being unavailable to potential attackers.
Even if an attacker has encrypt.exe anfd/or decrypt.exe and/or the seed that was used at his disposal,
it is useless without the information that is provided by "primes.in".

A suitable "primes.in" can be generated by running genprime.exe. (See the comments in genprime.c)
There is, however, already a "primes.in" provided in this repo, for the purposes of demonstration.

The "next_seed.txt" file needs to be found by "encrypt.exe", but "decrypt.exe" does not need it.
The "next_seed.txt" file contains a seed value that is continually auto-incremented so that the same
one-time pad is never reused.

And there's a perl test script (test.pl) which can be run to test that the encrypted file does,
indeed, decrypt back to the original file (which is autogenerated pseudorandomly by test.pl).


